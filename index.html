<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Микросостояния белка</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');

  :root {
    --bg: #161618;
    --surface: #1c1c1e;
    --surface2: #232325;
    --border: #38383a;
    --border-light: #2c2c2e;
    --accent: #0a84ff;
    --accent-hover: #409cff;
    --text: #f5f5f7;
    --text-secondary: #98989d;
    --text-tertiary: #54545a;
    --helix: #ff6b4a;
    --sheet: #409cff;
    --coil: #30d158;
    --turn: #bf5af2;
    --helix-bg: rgba(255,107,74,0.12);
    --sheet-bg: rgba(64,156,255,0.12);
    --coil-bg: rgba(48,209,88,0.1);
    --turn-bg: rgba(191,90,242,0.12);
    --canvas-bg: #0d0d0f;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 13px;
    min-height: 100vh;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
  }

  .header {
    height: 52px;
    padding: 0 24px;
    background: rgba(28,28,30,0.9);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border-light);
    display: flex;
    align-items: center;
    gap: 12px;
    position: sticky;
    top: 0;
    z-index: 100;
  }

  .header-title {
    font-size: 15px;
    font-weight: 600;
    color: var(--text);
    letter-spacing: -0.01em;
  }

  .header-sep {
    width: 1px;
    height: 16px;
    background: var(--border);
  }

  .header-sub {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 400;
  }

  .main-layout {
    display: grid;
    grid-template-columns: 300px 1fr 284px;
    height: calc(100vh - 52px);
  }

  .panel {
    background: var(--surface);
    border-right: 1px solid var(--border-light);
    overflow-y: auto;
    padding: 0;
  }

  .panel:last-child {
    border-right: none;
    border-left: 1px solid var(--border-light);
  }

  .panel-section {
    padding: 16px 16px 0;
    border-bottom: 1px solid var(--border-light);
    padding-bottom: 16px;
  }

  .panel-title {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.06em;
    margin-bottom: 10px;
  }

  /* SEQUENCE INPUT */
  .seq-input {
    width: 100%;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    padding: 9px 10px;
    resize: vertical;
    min-height: 72px;
    outline: none;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    transition: border-color 0.15s, box-shadow 0.15s;
    line-height: 1.6;
  }
  .seq-input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(10,132,255,0.2);
  }

  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    padding: 7px 12px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 7px;
    color: var(--text);
    font-family: 'Inter', sans-serif;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    width: 100%;
    margin-top: 5px;
    letter-spacing: -0.01em;
  }
  .btn:hover {
    background: #2c2c2e;
    border-color: #48484a;
  }
  .btn:active { transform: scale(0.98); }

  .btn.primary {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
    font-weight: 600;
  }
  .btn.primary:hover { background: var(--accent-hover); }

  .btn.danger {
    color: #ff6b6b;
    border-color: rgba(255,107,107,0.25);
    background: rgba(255,107,107,0.08);
  }
  .btn.danger:hover { background: rgba(255,107,107,0.15); border-color: rgba(255,107,107,0.4); }

  .btn.success {
    color: #30d158;
    border-color: rgba(48,209,88,0.25);
    background: rgba(48,209,88,0.08);
  }
  .btn.success:hover { background: rgba(48,209,88,0.15); border-color: rgba(48,209,88,0.4); }

  .btn-row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 5px;
    margin-top: 5px;
  }
  .btn-row .btn { margin-top: 0; font-size: 11px; padding: 6px 8px; }

  /* AMINO ACID CHAIN VIZ */
  .chain-container {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
  }

  .aa-badge {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    font-weight: 500;
    cursor: pointer;
    border: 1px solid transparent;
    border-radius: 4px;
    transition: all 0.2s cubic-bezier(0.34,1.56,0.64,1);
    position: relative;
  }

  .aa-badge.helix { background: var(--helix-bg); border-color: rgba(255,107,74,0.4); color: var(--helix); }
  .aa-badge.sheet { background: var(--sheet-bg); border-color: rgba(64,156,255,0.4); color: var(--sheet); }
  .aa-badge.coil  { background: var(--coil-bg);  border-color: rgba(48,209,88,0.35); color: var(--coil); }
  .aa-badge.turn  { background: var(--turn-bg);  border-color: rgba(191,90,242,0.4); color: var(--turn); }

  .aa-badge.selected { transform: scale(1.25); box-shadow: 0 2px 8px rgba(0,0,0,0.15); z-index: 2; }
  .aa-badge.transitioning { animation: pulse-aa 0.45s cubic-bezier(0.34,1.56,0.64,1); }

  @keyframes pulse-aa {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.3); }
  }

  /* CONTROLS */
  .slider-group { margin: 8px 0 4px; }
  .slider-label {
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .slider-label span {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--text);
    font-weight: 500;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 1px 6px;
  }
  input[type=range] {
    width: 100%;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
  }
  input[type=range]::-webkit-slider-thumb {
    appearance: none;
    width: 16px; height: 16px;
    border-radius: 50%;
    background: var(--surface);
    border: 2px solid var(--accent);
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.5);
    transition: transform 0.1s;
  }
  input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }

  /* STATE SELECTOR */
  .state-cards {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
  }
  .state-card {
    padding: 10px 8px;
    border: 1px solid var(--border-light);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.15s;
    font-size: 11px;
    text-align: center;
    background: var(--surface);
  }
  .state-card:hover { background: var(--surface2); }
  .state-card.helix:hover, .state-card.helix.active { background: var(--helix-bg); border-color: rgba(255,107,74,0.35); }
  .state-card.sheet:hover, .state-card.sheet.active { background: var(--sheet-bg); border-color: rgba(64,156,255,0.35); }
  .state-card.coil:hover,  .state-card.coil.active  { background: var(--coil-bg);  border-color: rgba(48,209,88,0.3); }
  .state-card.turn:hover,  .state-card.turn.active  { background: var(--turn-bg);  border-color: rgba(191,90,242,0.35); }
  .state-card .sc-symbol { font-size: 20px; line-height: 1.2; margin-bottom: 3px; }
  .state-card .sc-name { font-weight: 600; color: var(--text); margin-bottom: 2px; }
  .state-card .sc-angles {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: var(--text-tertiary);
  }
  .state-card.helix .sc-symbol { color: var(--helix); }
  .state-card.sheet .sc-symbol { color: var(--sheet); }
  .state-card.coil  .sc-symbol { color: var(--coil); }
  .state-card.turn  .sc-symbol { color: var(--turn); }

  /* CANVAS */
  .viz-container {
    position: relative;
    overflow: hidden;
    background: var(--canvas-bg);
  }

  canvas#mainCanvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  .viz-overlay {
    position: absolute;
    top: 16px;
    left: 16px;
    pointer-events: none;
  }
  .viz-overlay .state-name {
    font-size: 22px;
    font-weight: 300;
    color: rgba(255,255,255,0.9);
    letter-spacing: -0.02em;
    margin-bottom: 3px;
  }
  .viz-overlay .state-desc {
    font-size: 11px;
    color: rgba(255,255,255,0.4);
    max-width: 260px;
    line-height: 1.4;
  }
  .viz-overlay .frame-info {
    margin-top: 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: rgba(255,255,255,0.25);
  }

  .energy-bar-container {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 280px;
    pointer-events: none;
  }
  .energy-label {
    font-size: 11px;
    color: rgba(255,255,255,0.4);
    text-align: center;
    margin-bottom: 5px;
    font-family: 'JetBrains Mono', monospace;
  }
  .energy-track {
    height: 3px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    overflow: hidden;
  }
  .energy-fill {
    height: 100%;
    border-radius: 2px;
    transition: width 1s ease, background 1s ease;
  }

  /* RIGHT PANEL - BIOPHYSICS */
  .param-group { margin-bottom: 4px; }

  .param-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 0;
    border-bottom: 1px solid var(--border-light);
  }
  .param-name { color: var(--text-secondary); font-size: 12px; }
  .param-value {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    font-weight: 500;
    color: var(--text);
    transition: all 0.4s;
    min-width: 80px;
    text-align: right;
  }
  .param-value.changed { animation: flash-val 0.5s ease; }
  @keyframes flash-val {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }

  /* RAMACHANDRAN MINI */
  canvas#ramaCanvas {
    display: block;
    width: 100%;
    border-radius: 8px;
    border: 1px solid var(--border-light);
    margin: 8px 0;
  }

  /* ENERGY LANDSCAPE */
  canvas#energyCanvas {
    display: block;
    width: 100%;
    border-radius: 8px;
    border: 1px solid var(--border-light);
    margin: 8px 0;
  }

  /* TRANSITION LOG */
  .log-container {
    font-size: 11px;
    max-height: 110px;
    overflow-y: auto;
    background: var(--surface2);
    padding: 8px 10px;
    border: 1px solid var(--border-light);
    border-radius: 8px;
  }
  .log-entry { padding: 2px 0; border-bottom: 1px solid var(--border-light); color: var(--text-secondary); }
  .log-entry:last-child { border-bottom: none; }
  .log-entry .ts { color: var(--text-tertiary); margin-right: 6px; font-family: 'JetBrains Mono', monospace; font-size: 10px; }
  .log-entry .ev { color: var(--accent); font-weight: 500; }
  .legend { display: flex; flex-wrap: wrap; gap: 8px; margin: 6px 0; }
  .legend-item { display: flex; align-items: center; gap: 5px; font-size: 11px; color: var(--text-secondary); }
  .legend-dot { width: 8px; height: 8px; border-radius: 2px; }

  /* ANIMATION CONTROLS */
  .anim-controls {
    display: flex;
    gap: 6px;
    margin: 6px 0;
  }
  .anim-btn {
    flex: 1;
    padding: 8px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 7px;
    color: var(--text-secondary);
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
    font-family: inherit;
  }
  .anim-btn:hover { background: var(--surface2); color: var(--text); border-color: var(--border); }
  .anim-btn.playing { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* PyMOL export */
  .pymol-output {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    max-height: 90px;
    overflow-y: auto;
    background: #1c1c1e;
    padding: 10px;
    color: #30d158;
    border: 1px solid var(--border-light);
    border-radius: 8px;
    white-space: pre;
    display: none;
    margin-top: 6px;
  }

  /* ZOOM CONTROLS on canvas */
  .zoom-controls {
    position: absolute;
    bottom: 56px;
    right: 16px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    z-index: 10;
  }
  .zoom-btn {
    width: 34px;
    height: 34px;
    background: rgba(28,28,30,0.75);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: rgba(255,255,255,0.75);
    font-size: 18px;
    font-weight: 300;
    line-height: 1;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    font-family: -apple-system, sans-serif;
    user-select: none;
  }
  .zoom-btn:hover {
    background: rgba(44,44,46,0.9);
    border-color: rgba(255,255,255,0.2);
    color: #fff;
  }
  .zoom-btn:active {
    transform: scale(0.93);
  }
  .zoom-label {
    width: 34px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: rgba(255,255,255,0.3);
    letter-spacing: 0.05em;
    user-select: none;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 4px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .tooltip {
    position: fixed;
    background: rgba(28,28,30,0.92);
    backdrop-filter: blur(12px);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 11px;
    pointer-events: none;
    z-index: 1000;
    display: none;
    color: #fff;
    max-width: 180px;
    line-height: 1.6;
    box-shadow: 0 4px 20px rgba(0,0,0,0.25);
  }
</style>
</head>
<body>

<div class="header">
  <div class="header-title">Микросостояния белка</div>
  <div class="header-sep"></div>
  <div class="header-sub">Биофизика · Конформационные переходы · Визуализация</div>
</div>

<div class="main-layout">

  <!-- LEFT PANEL -->
  <div class="panel">

    <div class="panel-section">
      <div class="panel-title">Последовательность</div>
      <textarea class="seq-input" id="seqInput" placeholder="ACDEFGHIKLMNPQRSTVWY...">ALANEGKQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG</textarea>
      <button class="btn primary" onclick="loadSequence()">Загрузить</button>
      <div class="btn-row">
        <button class="btn" onclick="loadPreset('ubiquitin')">Убиквитин</button>
        <button class="btn" onclick="loadPreset('helix')">Poly-Ala</button>
        <button class="btn" onclick="loadPreset('sheet')">β-пептид</button>
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Цепочка — кликните на остаток</div>
      <div class="chain-container" id="chainContainer"></div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Присвоить микросостояние</div>
      <div class="state-cards">
        <div class="state-card helix" onclick="applyState('helix')">
          <div class="sc-symbol">α</div>
          <div class="sc-name">α-спираль</div>
          <div class="sc-angles">φ −57° ψ −47°</div>
        </div>
        <div class="state-card sheet" onclick="applyState('sheet')">
          <div class="sc-symbol">β</div>
          <div class="sc-name">β-лист</div>
          <div class="sc-angles">φ −119° ψ +113°</div>
        </div>
        <div class="state-card coil" onclick="applyState('coil')">
          <div class="sc-symbol">~</div>
          <div class="sc-name">Петля</div>
          <div class="sc-angles">φ,ψ ∈ [−180°,180°]</div>
        </div>
        <div class="state-card turn" onclick="applyState('turn')">
          <div class="sc-symbol">∩</div>
          <div class="sc-name">β-поворот</div>
          <div class="sc-angles">φ −60° ψ −30°</div>
        </div>
      </div>
      <button class="btn danger" onclick="randomizeStates()">Случайные состояния</button>
      <button class="btn" onclick="monteCarloStep()">Шаг Монте-Карло</button>
    </div>

    <div class="panel-section">
      <div class="panel-title">Параметры симуляции</div>
      <div class="slider-group">
        <div class="slider-label">Температура (T) <span id="tempVal">298 K</span></div>
        <input type="range" id="tempSlider" min="100" max="500" value="298" oninput="updateParams()">
      </div>
      <div class="slider-group" style="margin-top:10px;">
        <div class="slider-label">Скорость анимации <span id="speedVal">1.0×</span></div>
        <input type="range" id="speedSlider" min="1" max="10" value="5" oninput="updateParams()">
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Анимация</div>
      <div class="anim-controls">
        <button class="anim-btn" id="btnPlay" onclick="togglePlay()">&#9654;</button>
        <button class="anim-btn" onclick="stepForward()">&#9654;&#9654;</button>
        <button class="anim-btn" onclick="resetAnim()">&#9664;&#9664;</button>
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Экспорт PyMOL</div>
      <button class="btn success" onclick="exportPyMOL()">Сгенерировать .pml скрипт</button>
      <div class="pymol-output" id="pymolOutput"></div>
    </div>

  </div>

  <!-- CENTER - MAIN VISUALIZATION -->
  <div class="viz-container" id="vizContainer">
    <canvas id="mainCanvas"></canvas>
    <div class="viz-overlay">
      <div class="state-name" id="stateName">Загрузите последовательность</div>
      <div class="state-desc" id="stateDesc">Выберите аминокислотную последовательность</div>
      <div class="frame-info" id="frameInfo"></div>
    </div>
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomIn()" title="Приблизить">+</button>
      <div class="zoom-label" id="zoomLabel">1.0×</div>
      <button class="zoom-btn" onclick="zoomOut()" title="Отдалить">−</button>
    </div>
    <div class="energy-bar-container">
      <div class="energy-label" id="energyLabel">Свободная энергия: — ккал/моль</div>
      <div class="energy-track">
        <div class="energy-fill" id="energyFill" style="width:50%;"></div>
      </div>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <div class="panel">

    <div class="panel-section">
      <div class="panel-title">Термодинамика</div>
      <div class="param-group">
        <div class="param-row">
          <span class="param-name">ΔG (ккал/моль)</span>
          <span class="param-value" id="pDG">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">ΔH (ккал/моль)</span>
          <span class="param-value" id="pDH">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">TΔS (ккал/моль)</span>
          <span class="param-value" id="pTDS">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">Keq</span>
          <span class="param-value" id="pKeq">—</span>
        </div>
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Геометрия</div>
      <div class="param-group">
        <div class="param-row">
          <span class="param-name">φ (фи), °</span>
          <span class="param-value" id="pPhi">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">ψ (пси), °</span>
          <span class="param-value" id="pPsi">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">Rg (нм)</span>
          <span class="param-value" id="pRg">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">End-to-end (нм)</span>
          <span class="param-value" id="pE2E">—</span>
        </div>
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Физические свойства</div>
      <div class="param-group">
        <div class="param-row">
          <span class="param-name">SASA (Å²)</span>
          <span class="param-value" id="pSASA">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">H-связей</span>
          <span class="param-value" id="pHbonds">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">Гидрофоб. контактов</span>
          <span class="param-value" id="pHphob">—</span>
        </div>
        <div class="param-row">
          <span class="param-name">κ (компактность)</span>
          <span class="param-value" id="pKappa">—</span>
        </div>
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Карта Рамачандрана</div>
      <canvas id="ramaCanvas" width="252" height="180"></canvas>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:var(--helix)"></div>α-спираль</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--sheet)"></div>β-лист</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--coil)"></div>Петля</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--turn)"></div>Поворот</div>
      </div>
    </div>

    <div class="panel-section">
      <div class="panel-title">Ландшафт свободной энергии</div>
      <canvas id="energyCanvas" width="252" height="120"></canvas>
    </div>

    <div class="panel-section">
      <div class="panel-title">Журнал переходов</div>
      <div class="log-container" id="logContainer">
        <div class="log-entry"><span class="ts">[init]</span> Система инициализирована</div>
      </div>
    </div>

  </div>

</div>

<div class="tooltip" id="tooltip"></div>

<script>
// ==================== DATA ====================
const AA_DATA = {
  A: { name: 'Ala', hydrophobicity: 1.8, charge: 0, size: 'small', propensity: {helix:1.41, sheet:0.72, coil:0.9, turn:0.72} },
  R: { name: 'Arg', hydrophobicity: -4.5, charge: +1, size: 'large', propensity: {helix:0.98, sheet:0.93, coil:1.0, turn:0.88} },
  N: { name: 'Asn', hydrophobicity: -3.5, charge: 0, size: 'medium', propensity: {helix:0.67, sheet:0.65, coil:1.0, turn:1.56} },
  D: { name: 'Asp', hydrophobicity: -3.5, charge: -1, size: 'medium', propensity: {helix:0.99, sheet:0.39, coil:1.0, turn:1.46} },
  C: { name: 'Cys', hydrophobicity: 2.5, charge: 0, size: 'small', propensity: {helix:0.77, sheet:1.30, coil:1.0, turn:0.81} },
  Q: { name: 'Gln', hydrophobicity: -3.5, charge: 0, size: 'medium', propensity: {helix:1.27, sheet:0.98, coil:1.0, turn:0.98} },
  E: { name: 'Glu', hydrophobicity: -3.5, charge: -1, size: 'medium', propensity: {helix:1.59, sheet:0.52, coil:1.0, turn:1.01} },
  G: { name: 'Gly', hydrophobicity: -0.4, charge: 0, size: 'tiny', propensity: {helix:0.43, sheet:0.58, coil:1.0, turn:1.77} },
  H: { name: 'His', hydrophobicity: -3.2, charge: 0.5, size: 'large', propensity: {helix:1.05, sheet:0.80, coil:1.0, turn:0.81} },
  I: { name: 'Ile', hydrophobicity: 4.5, charge: 0, size: 'large', propensity: {helix:1.09, sheet:1.67, coil:1.0, turn:0.47} },
  L: { name: 'Leu', hydrophobicity: 3.8, charge: 0, size: 'large', propensity: {helix:1.34, sheet:1.22, coil:1.0, turn:0.57} },
  K: { name: 'Lys', hydrophobicity: -3.9, charge: +1, size: 'large', propensity: {helix:1.23, sheet:0.69, coil:1.0, turn:1.07} },
  M: { name: 'Met', hydrophobicity: 1.9, charge: 0, size: 'large', propensity: {helix:1.30, sheet:1.14, coil:1.0, turn:0.52} },
  F: { name: 'Phe', hydrophobicity: 2.8, charge: 0, size: 'large', propensity: {helix:1.07, sheet:1.32, coil:1.0, turn:0.58} },
  P: { name: 'Pro', hydrophobicity: -1.6, charge: 0, size: 'medium', propensity: {helix:0.57, sheet:0.55, coil:1.0, turn:1.52} },
  S: { name: 'Ser', hydrophobicity: -0.8, charge: 0, size: 'small', propensity: {helix:0.79, sheet:0.72, coil:1.0, turn:1.43} },
  T: { name: 'Thr', hydrophobicity: -0.7, charge: 0, size: 'medium', propensity: {helix:0.82, sheet:1.20, coil:1.0, turn:1.03} },
  W: { name: 'Trp', hydrophobicity: -0.9, charge: 0, size: 'huge', propensity: {helix:1.02, sheet:1.35, coil:1.0, turn:0.65} },
  Y: { name: 'Tyr', hydrophobicity: -1.3, charge: 0, size: 'huge', propensity: {helix:0.72, sheet:1.25, coil:1.0, turn:1.05} },
  V: { name: 'Val', hydrophobicity: 4.2, charge: 0, size: 'medium', propensity: {helix:0.90, sheet:1.87, coil:1.0, turn:0.41} },
};

const STATE_PHI_PSI = {
  helix: { phi: -57, psi: -47, color: '#ff6b35', colorRGB: [255,107,53] },
  sheet: { phi: -119, psi: 113, color: '#00d4ff', colorRGB: [0,212,255] },
  coil:  { phi: 0,   psi: 0,   color: '#39ff14', colorRGB: [57,255,20], random: true },
  turn:  { phi: -60, psi: -30, color: '#bf5af2', colorRGB: [191,90,242] },
};

const PRESETS = {
  ubiquitin: 'MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGG',
  helix: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAA',
  sheet: 'VIVTVIVTVIVTVIVTVIVT',
};

// ==================== STATE ====================
let sequence = [];
let residueStates = [];
let selectedResidue = -1;
let isPlaying = false;
let playInterval = null;
let mcStep = 0;
let temperature = 298;
let animSpeed = 5;
let transitionHistory = [];
let currentStateLabel = '';
let prevParams = {};

// ==================== INIT ====================
window.onload = () => {
  loadSequence();
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  drawRamachandran();
  document.getElementById('mainCanvas').addEventListener('wheel', e => {
    e.preventDefault();
    if(e.deltaY < 0) zoomIn(); else zoomOut();
  }, { passive: false });
};

function resizeCanvas() {
  const c = document.getElementById('mainCanvas');
  const container = document.getElementById('vizContainer');
  // Use higher effective DPR for extra sharpness (cap at 3 to avoid memory issues)
  const dpr = Math.min(window.devicePixelRatio || 1, 3) * 1.5;
  const w = container.clientWidth;
  const h = container.clientHeight;
  c.width = Math.floor(w * dpr);
  c.height = Math.floor(h * dpr);
  c.style.width = w + 'px';
  c.style.height = h + 'px';
  c.dataset.logicalW = w;
  c.dataset.logicalH = h;
  c.dataset.dpr = dpr;
  render();
}

function loadPreset(name) {
  document.getElementById('seqInput').value = PRESETS[name];
  loadSequence();
}

function loadSequence() {
  const raw = document.getElementById('seqInput').value.toUpperCase().replace(/[^ACDEFGHIKLMNPQRSTVWY]/g,'');
  if(raw.length === 0) return;
  sequence = raw.split('');
  residueStates = sequence.map(aa => {
    // Assign state by propensity
    const d = AA_DATA[aa] || AA_DATA['A'];
    const p = d.propensity;
    const total = p.helix + p.sheet + p.coil + p.turn;
    const r = Math.random() * total;
    let acc = 0;
    for(const s of ['helix','sheet','coil','turn']) {
      acc += p[s];
      if(r < acc) return s;
    }
    return 'coil';
  });
  buildChainUI();
  updateAll();
  logEvent('Загружена последовательность: ' + sequence.length + ' остатков');
}

function buildChainUI() {
  const c = document.getElementById('chainContainer');
  c.innerHTML = '';
  sequence.forEach((aa, i) => {
    const d = document.createElement('div');
    d.className = 'aa-badge ' + residueStates[i];
    d.textContent = aa;
    d.dataset.index = i;
    d.title = (AA_DATA[aa]?.name || aa) + ' #' + (i+1);
    d.addEventListener('click', () => selectResidue(i));
    d.addEventListener('mouseenter', (e) => showTooltip(e, aa, i));
    d.addEventListener('mouseleave', () => hideTooltip());
    c.appendChild(d);
  });
}

function showTooltip(e, aa, i) {
  const d = AA_DATA[aa] || {};
  const t = document.getElementById('tooltip');
  t.style.display = 'block';
  t.style.left = (e.clientX + 10) + 'px';
  t.style.top = (e.clientY - 40) + 'px';
  t.innerHTML = `<b>${d.name || aa} #${i+1}</b><br>
    Гидрофобность: ${d.hydrophobicity}<br>
    Заряд: ${d.charge > 0 ? '+' : ''}${d.charge}<br>
    Состояние: ${residueStates[i]}<br>
    Пропенсивность α: ${d.propensity?.helix?.toFixed(2)}`;
}

function hideTooltip() {
  document.getElementById('tooltip').style.display = 'none';
}

function selectResidue(i) {
  selectedResidue = selectedResidue === i ? -1 : i;
  buildChainUI();
  if(selectedResidue >= 0) {
    const badges = document.querySelectorAll('.aa-badge');
    badges[i]?.classList.add('selected');
  }
  updateBiophysics();
}

// ==================== STATE APPLICATION ====================
function applyState(state) {
  if(selectedResidue >= 0) {
    const old = residueStates[selectedResidue];
    residueStates[selectedResidue] = state;
    logEvent(`Остаток ${sequence[selectedResidue]}${selectedResidue+1}: ${old} → ${state}`, true);
    animateTransition(selectedResidue);
  } else {
    // Apply to all
    const old = [...residueStates];
    residueStates = residueStates.map((_, i) => {
      if(state === 'coil') return state;
      const d = AA_DATA[sequence[i]] || AA_DATA['A'];
      return state;
    });
    logEvent(`Все остатки → ${state}`);
  }
  buildChainUI();
  if(selectedResidue >= 0) {
    document.querySelectorAll('.aa-badge')[selectedResidue]?.classList.add('selected');
  }
  updateAll();
}

function randomizeStates() {
  const old = [...residueStates];
  residueStates = sequence.map((aa, i) => {
    const d = AA_DATA[aa] || AA_DATA['A'];
    const p = d.propensity;
    const T_factor = temperature / 298;
    // At high T, flatten propensities
    const flat = {
      helix: 1 + (p.helix - 1) / T_factor,
      sheet: 1 + (p.sheet - 1) / T_factor,
      coil:  1 + (p.coil  - 1) / T_factor,
      turn:  1 + (p.turn  - 1) / T_factor,
    };
    const total = flat.helix + flat.sheet + flat.coil + flat.turn;
    const r = Math.random() * total;
    let acc = 0;
    for(const s of ['helix','sheet','coil','turn']) {
      acc += flat[s];
      if(r < acc) return s;
    }
    return 'coil';
  });
  buildChainUI();
  updateAll();
  logEvent(`Случайные состояния при T=${temperature}K`);
}

function monteCarloStep() {
  if(sequence.length === 0) return;
  const i = Math.floor(Math.random() * sequence.length);
  const states = ['helix','sheet','coil','turn'];
  const newState = states[Math.floor(Math.random() * states.length)];
  const oldState = residueStates[i];
  
  const dG = calcDeltaG(i, oldState, newState);
  const kT = 0.001987 * temperature;
  const accept = dG <= 0 || Math.random() < Math.exp(-dG / kT);
  
  if(accept) {
    residueStates[i] = newState;
    animateTransition(i);
    logEvent(`MC: ${sequence[i]}${i+1} ${oldState}→${newState} ΔG=${dG.toFixed(2)} ✓`, true);
    buildChainUI();
    if(selectedResidue >= 0) document.querySelectorAll('.aa-badge')[selectedResidue]?.classList.add('selected');
    updateAll();
  } else {
    logEvent(`MC: ${sequence[i]}${i+1} ${oldState}→${newState} ΔG=${dG.toFixed(2)} ✗`);
  }
  mcStep++;
}

function calcDeltaG(i, oldState, newState) {
  const aa = sequence[i];
  const d = AA_DATA[aa] || AA_DATA['A'];
  const propOld = d.propensity[oldState];
  const propNew = d.propensity[newState];
  // Simplified: ΔG based on propensity difference + hydrophobicity + entropy
  const kT = 0.001987 * temperature;
  const ddG = -kT * Math.log(propNew / propOld);
  const hydro = d.hydrophobicity;
  const hydro_factor = (newState === 'helix' || newState === 'sheet') ? -0.1 * hydro : 0.05 * hydro;
  return ddG + hydro_factor;
}

function animateTransition(i) {
  const badges = document.querySelectorAll('.aa-badge');
  const badge = badges[i];
  if(!badge) return;
  badge.classList.add('transitioning');
  setTimeout(() => badge.classList.remove('transitioning'), 600);
}

// ==================== BIOPHYSICS CALC ====================
function calcBiophysics() {
  if(sequence.length === 0) return {};
  
  const n = sequence.length;
  const T = temperature;
  const kT = 0.001987 * T;
  const R = 1.987; // cal/mol/K
  
  // Count states
  const counts = {helix:0, sheet:0, coil:0, turn:0};
  residueStates.forEach(s => counts[s]++);
  
  // Phi/Psi averages
  let sumPhi = 0, sumPsi = 0;
  residueStates.forEach(s => {
    const sp = STATE_PHI_PSI[s];
    sumPhi += sp.random ? (Math.random()*360-180) : sp.phi;
    sumPsi += sp.random ? (Math.random()*360-180) : sp.psi;
  });
  const avgPhi = sumPhi / n;
  const avgPsi = sumPsi / n;
  
  // H-bonds (helix: 3.6 per turn, sheet: inter-strand)
  const hBonds = Math.round(counts.helix * 0.9 + counts.sheet * 0.8 + counts.turn * 0.4);
  
  // Radius of gyration (simplified)
  const helixRg = counts.helix * 0.5; // Å per residue in helix
  const sheetRg = counts.sheet * 2.5;
  const coilRg  = counts.coil * 3.8;
  const Rg = Math.sqrt((helixRg + sheetRg + coilRg) / n) * 0.1; // nm
  
  // End-to-end
  const e2e = Rg * (0.8 + Math.random() * 0.4);
  
  // SASA (simplified)
  const SASA = n * 110 - hBonds * 15;
  
  // Hydrophobic contacts
  const hphobResidues = sequence.filter(aa => (AA_DATA[aa]?.hydrophobicity || 0) > 2).length;
  const buriedFraction = (counts.helix + counts.sheet) / n;
  const hphobContacts = Math.round(hphobResidues * buriedFraction * 0.7);
  
  // Compactness kappa
  const kappa = 1 - (4 * Math.PI * Rg*Rg) / (Math.PI * Math.pow(3*n*0.135/(4*Math.PI), 2/3));
  
  // Thermodynamics
  const S_helix = -0.7, S_sheet = -0.5, S_coil = 0.5, S_turn = -0.3; // cal/mol/K per residue
  const H_helix = -2.5, H_sheet = -1.5, H_coil = 0.5, H_turn = -0.8; // kcal/mol per residue
  
  const deltaH = (counts.helix*H_helix + counts.sheet*H_sheet + counts.coil*H_coil + counts.turn*H_turn) / n;
  const deltaS = (counts.helix*S_helix + counts.sheet*S_sheet + counts.coil*S_coil + counts.turn*S_turn) / n;
  const TdeltaS = T * deltaS * 0.001; // kcal/mol
  const deltaG = deltaH - TdeltaS;
  const Keq = Math.exp(-deltaG / kT);
  
  return {
    phi: avgPhi.toFixed(1),
    psi: avgPsi.toFixed(1),
    Rg: Rg.toFixed(2),
    e2e: e2e.toFixed(2),
    SASA: Math.round(SASA),
    hBonds,
    hphobContacts,
    kappa: Math.max(0, Math.min(1, kappa)).toFixed(3),
    deltaG: deltaG.toFixed(2),
    deltaH: deltaH.toFixed(2),
    TdeltaS: TdeltaS.toFixed(2),
    Keq: Keq > 1e6 ? '>' + 1e6 : Keq.toFixed(2),
    counts,
  };
}

function updateBiophysics() {
  const p = calcBiophysics();
  if(!p.phi) return;
  
  const fields = [
    ['pDG', p.deltaG + ' ккал/моль'],
    ['pDH', p.deltaH + ' ккал/моль'],
    ['pTDS', p.TdeltaS + ' ккал/моль'],
    ['pKeq', String(p.Keq)],
    ['pPhi', p.phi + '\u00b0'],
    ['pPsi', p.psi + '\u00b0'],
    ['pRg', String(p.Rg)],
    ['pE2E', String(p.e2e)],
    ['pSASA', String(p.SASA)],
    ['pHbonds', String(p.hBonds)],
    ['pHphob', String(p.hphobContacts)],
    ['pKappa', String(p.kappa)],
  ];
  
  fields.forEach(function(pair) {
    var id = pair[0], val = pair[1];
    var el = document.getElementById(id);
    if(el && el.textContent !== val) {
      el.classList.remove('changed');
      el.classList.add('changed');
      el.textContent = val;
    }
  });
  
  // Energy bar
  const gNorm = Math.max(0, Math.min(1, (parseFloat(p.deltaG) + 5) / 10));
  const hue = gNorm < 0.5 ? ('hsl(' + (120 + gNorm*120) + ', 100%, 50%)') : ('hsl(' + (120 + gNorm*120) + ', 100%, 50%)');
  document.getElementById('energyFill').style.width = (gNorm * 100) + '%';
  document.getElementById('energyFill').style.background = `hsl(${180 - gNorm * 180}, 100%, 50%)`;
  document.getElementById('energyLabel').textContent = `Свободная энергия: ${p.deltaG} ккал/моль`;
  
  // State label
  const dom = Object.entries(p.counts).sort((a,b)=>b[1]-a[1])[0];
  const labels = {helix:'α-Спираль', sheet:'β-Лист', coil:'Хаотический клубок', turn:'β-Поворот'};
  const descs = {
    helix:'Регулярная водородная сеть (i→i+4), полярные диполи, жёсткий стержень',
    sheet:'Межцепочечные H-связи, гидрофобное ядро, амфипатичность',
    coil:'Высокая энтропия, максимальная гибкость, полная экспозиция SASA',
    turn:'Изменение направления цепи, γ- или β-поворот, часто Pro/Gly'
  };
  document.getElementById('stateName').textContent = labels[dom[0]] || '—';
  document.getElementById('stateDesc').textContent = descs[dom[0]] || '—';
  document.getElementById('frameInfo').textContent = 
    `α:${p.counts.helix} β:${p.counts.sheet} coil:${p.counts.coil} turn:${p.counts.turn} | MC шагов: ${mcStep}`;
  
  drawRamachandranPoints(p);
  drawEnergyLandscape(p);
  prevParams = p;
  return p;
}

function updateParams() {
  temperature = parseInt(document.getElementById('tempSlider').value);
  animSpeed = parseInt(document.getElementById('speedSlider').value);
  document.getElementById('tempVal').textContent = temperature + ' K';
  document.getElementById('speedVal').textContent = (animSpeed/5).toFixed(1) + '×';
  updateAll();
}

function updateAll() {
  updateBiophysics();
  render();
}

// ==================== RAMACHANDRAN ====================
function drawRamachandran() {
  const c = document.getElementById('ramaCanvas');
  const dpr = Math.min(window.devicePixelRatio || 1, 3) * 1.5;
  const logW = c.offsetWidth || 252;
  const logH = 180;
  c.width = Math.floor(logW * dpr);
  c.height = Math.floor(logH * dpr);
  c.style.width = logW + 'px';
  c.style.height = logH + 'px';
  const ctx = c.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = logW, H = logH;
  ctx.fillStyle = '#1c1c1e';
  ctx.fillRect(0, 0, W, H);
  
  // Allowed regions (simplified)
  ctx.strokeStyle = 'rgba(255,255,255,0.07)';
  ctx.lineWidth = 1;
  // Axes
  ctx.beginPath();
  ctx.moveTo(W/2,0); ctx.lineTo(W/2,H);
  ctx.moveTo(0,H/2); ctx.lineTo(W,H/2);
  ctx.stroke();
  
  // Region labels
  ctx.font = '8px Inter, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.fillText('φ →', W-25, H/2-4);
  ctx.fillText('ψ ↑', W/2+4, 10);
  ctx.fillText('-180', 0, H/2-4);
  ctx.fillText('180', W-24, H/2-4);
  
  // Draw allowed zones
  const zoneStyle = (color) => {
    ctx.fillStyle = color;
    ctx.strokeStyle = color.replace('0.15','0.4');
    ctx.lineWidth = 1;
  };
  
  // Alpha helix zone
  const phiToX = phi => (phi + 180) / 360 * W;
  const psiToY = psi => (1 - (psi + 180) / 360) * H;
  
  ctx.fillStyle = 'rgba(255,107,74,0.15)';
  ctx.strokeStyle = 'rgba(255,107,74,0.4)';
  ctx.beginPath();
  ctx.ellipse(phiToX(-57), psiToY(-47), 30, 35, 0, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();
  
  // Beta sheet zone
  ctx.fillStyle = 'rgba(64,156,255,0.15)';
  ctx.strokeStyle = 'rgba(64,156,255,0.4)';
  ctx.beginPath();
  ctx.ellipse(phiToX(-119), psiToY(113), 35, 30, 0, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();
  
  // Left helix zone  
  ctx.fillStyle = 'rgba(191,90,242,0.1)';
  ctx.strokeStyle = 'rgba(191,90,242,0.3)';
  ctx.beginPath();
  ctx.ellipse(phiToX(57), psiToY(47), 20, 25, 0, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();
  
  // Zone labels
  ctx.font = '7px Inter, sans-serif';
  ctx.fillStyle = 'rgba(255,107,74,0.9)';
  ctx.fillText('α', phiToX(-57)-4, psiToY(-47)+3);
  ctx.fillStyle = 'rgba(64,156,255,0.9)';
  ctx.fillText('β', phiToX(-119)-4, psiToY(113)+3);
  ctx.fillStyle = 'rgba(191,90,242,0.9)';
  ctx.fillText('αL', phiToX(57)-4, psiToY(47)+3);
}

function drawRamachandranPoints(p) {
  const c = document.getElementById('ramaCanvas');
  const ctx = c.getContext('2d');
  drawRamachandran();
  const dpr = Math.min(window.devicePixelRatio || 1, 3) * 1.5;
  const W = c.width / dpr, H = c.height / dpr;
  const phiToX = phi => (phi + 180) / 360 * W;
  const psiToY = psi => (1 - (psi + 180) / 360) * H;
  
  // Draw all residues
  sequence.forEach((aa, i) => {
    const s = residueStates[i];
    const sp = STATE_PHI_PSI[s];
    let phi = sp.phi, psi = sp.psi;
    if(sp.random) {
      // Use a seeded-like value based on index
      phi = ((i * 137.5) % 360) - 180;
      psi = ((i * 97.3 + 50) % 360) - 180;
    } else {
      phi += (Math.random() - 0.5) * 20;
      psi += (Math.random() - 0.5) * 20;
    }
    
    ctx.beginPath();
    ctx.arc(phiToX(phi), psiToY(psi), i === selectedResidue ? 5 : 2.5, 0, Math.PI*2);
    ctx.fillStyle = sp.color + (i === selectedResidue ? 'ff' : '99');
    ctx.fill();
    
    if(i === selectedResidue) {
      ctx.strokeStyle = sp.color;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  });
}

// ==================== ENERGY LANDSCAPE ====================
function drawEnergyLandscape(p) {
  const c = document.getElementById('energyCanvas');
  const dpr = Math.min(window.devicePixelRatio || 1, 3) * 1.5;
  const logW = c.offsetWidth || 252;
  const logH = 120;
  c.width = Math.floor(logW * dpr);
  c.height = Math.floor(logH * dpr);
  c.style.width = logW + 'px';
  c.style.height = logH + 'px';
  const ctx = c.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = logW, H = logH;
  ctx.fillStyle = '#161618';
  ctx.fillRect(0, 0, W, H);
  
  // Draw 1D energy landscape (reaction coordinate)
  const stateOrder = ['helix', 'coil', 'sheet', 'coil', 'turn'];
  const energyLevels = {
    helix: -3.0 - (p.counts?.helix || 0) * 0.05,
    sheet: -2.5 - (p.counts?.sheet || 0) * 0.05,
    coil:  0.5 + (temperature - 298) * 0.003,
    turn:  -1.5,
  };
  
  const barriers = { 'helix-coil': 3.5, 'coil-sheet': 2.8, 'sheet-coil': 2.5, 'coil-turn': 2.0 };
  
  const n = 200;
  const points = [];
  
  for(let x = 0; x < n; x++) {
    const t = x / n;
    let E = 0;
    // Superposition of energy wells
    E += -3.0 * Math.exp(-Math.pow((t - 0.15)*8, 2)); // helix well
    E += -2.5 * Math.exp(-Math.pow((t - 0.55)*8, 2)); // sheet well
    E += -1.5 * Math.exp(-Math.pow((t - 0.85)*10, 2)); // turn well
    E += 2.0 * Math.exp(-Math.pow((t - 0.35)*12, 2)); // barrier 1
    E += 1.5 * Math.exp(-Math.pow((t - 0.7)*12, 2));  // barrier 2
    E += 0.3 * (temperature - 298) / 100; // temperature shift
    points.push({x: x/n * W, E});
  }
  
  const minE = Math.min(...points.map(p=>p.E));
  const maxE = Math.max(...points.map(p=>p.E));
  const range = maxE - minE;
  
  const toY = E => H - 15 - ((E - minE) / range) * (H - 25);
  
  // Draw grid
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 0.5;
  for(let y = 0; y <= 4; y++) {
    const yp = 10 + y * (H-20)/4;
    ctx.beginPath(); ctx.moveTo(0, yp); ctx.lineTo(W, yp); ctx.stroke();
  }
  
  // Draw thermal energy kT line
  const kT_kcal = 0.001987 * temperature;
  const kT_y = toY(minE + kT_kcal / range * (maxE - minE) * 3);
  ctx.setLineDash([3,3]);
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, Math.max(10, kT_y));
  ctx.lineTo(W, Math.max(10, kT_y));
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.font = '7px Inter, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.fillText('kT', 2, Math.max(18, kT_y - 2));
  
  // Draw energy curve
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, 'rgba(255,107,74,1)');
  grad.addColorStop(0.5, 'rgba(64,156,255,1)');
  grad.addColorStop(1, 'rgba(48,209,88,1)');
  
  ctx.beginPath();
  ctx.strokeStyle = grad;
  ctx.lineWidth = 2;
  points.forEach((p, i) => {
    if(i === 0) ctx.moveTo(p.x, toY(p.E));
    else ctx.lineTo(p.x, toY(p.E));
  });
  ctx.stroke();
  
  // Fill under curve
  ctx.beginPath();
  points.forEach((p, i) => {
    if(i === 0) ctx.moveTo(p.x, toY(p.E));
    else ctx.lineTo(p.x, toY(p.E));
  });
  ctx.lineTo(W, H); ctx.lineTo(0, H); ctx.closePath();
  ctx.fillStyle = 'rgba(64,156,255,0.06)';
  ctx.fill();
  
  // Label minima
  const labels2 = [{x:0.15, label:'α'}, {x:0.55, label:'β'}, {x:0.85, label:'∩'}];
  labels2.forEach((l, i) => {
    const xp = l.x * W;
    const ptIdx = Math.round(l.x * (n-1));
    const yp = toY(points[ptIdx].E);
    ctx.fillStyle = ['#ff6b4a','#409cff','#bf5af2'][i];
    ctx.font = 'bold 9px Inter, sans-serif';
    ctx.fillText(l.label, xp - 3, yp - 5);
  });
  
  // Label axes
  ctx.font = '7px Inter, sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.fillText('G', 2, 10);
  ctx.fillText('RC →', W-25, H-2);
}

// ==================== 3D VISUALIZATION ====================
let time = 0;
let animFrame = null;
let zoomLevel = 1.0;
const ZOOM_MIN = 0.25;
const ZOOM_MAX = 4.0;
const ZOOM_STEP = 0.2;

function zoomIn() {
  zoomLevel = Math.min(ZOOM_MAX, parseFloat((zoomLevel + ZOOM_STEP).toFixed(2)));
  document.getElementById('zoomLabel').textContent = zoomLevel.toFixed(1) + '×';
  render();
}

function zoomOut() {
  zoomLevel = Math.max(ZOOM_MIN, parseFloat((zoomLevel - ZOOM_STEP).toFixed(2)));
  document.getElementById('zoomLabel').textContent = zoomLevel.toFixed(1) + '×';
  render();
}

function render() {
  const canvas = document.getElementById('mainCanvas');
  const ctx = canvas.getContext('2d');
  const dpr = parseFloat(canvas.dataset.dpr) || window.devicePixelRatio || 1;
  const W = parseFloat(canvas.dataset.logicalW) || canvas.width / dpr;
  const H = parseFloat(canvas.dataset.logicalH) || canvas.height / dpr;
  if(W === 0 || H === 0) return;
  
  ctx.save();
  ctx.scale(dpr, dpr);
  ctx.clearRect(0, 0, W, H);
  
  if(sequence.length === 0) {
    ctx.font = '14px -apple-system, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.18)';
    ctx.textAlign = 'center';
    ctx.fillText('Загрузите аминокислотную последовательность', W/2, H/2);
    ctx.textAlign = 'left';
    ctx.restore();
    return;
  }
  
  drawProteinChain3D(ctx, W, H);
  ctx.restore();
}

function drawProteinChain3D(ctx, W, H) {
  const n = sequence.length;
  const cx = W * 0.5;
  const cy = H * 0.5;
  const scale = Math.min(W, H) * 0.35 * zoomLevel;
  
  // Build 3D coordinates based on states
  const coords = [];
  let x=0, y=0, z=0;
  let phi_rad=0, psi_rad=0, theta=0;
  
  sequence.forEach((aa, i) => {
    const s = residueStates[i];
    const sp = STATE_PHI_PSI[s];
    
    // Step based on secondary structure
    let dx, dy, dz;
    const t = time * 0.01;
    
    if(s === 'helix') {
      // Helical path
      const rise = 1.5; // Å per residue
      const radius_helix = 2.3;
      const angle = i * (100 * Math.PI / 180); // 100° per residue
      dx = Math.cos(angle + t) * 0.2 * rise;
      dy = Math.sin(angle + t) * 0.2 * rise;
      dz = rise;
    } else if(s === 'sheet') {
      // Extended
      const sign = i % 2 === 0 ? 1 : -1;
      dx = 3.5; // Å per residue
      dy = sign * 0.5 + Math.sin(t * 0.5) * 0.1;
      dz = 0.1;
    } else if(s === 'coil') {
      // Random coil
      dx = (Math.sin(i*1.7 + t) * 2 + (Math.random()-0.5)*0.5);
      dy = (Math.cos(i*2.3 + t*1.1) * 2 + (Math.random()-0.5)*0.5);
      dz = (Math.sin(i*0.9 + t*0.7) * 1.5);
    } else {
      // Turn
      const turnAngle = i * (85 * Math.PI/180);
      dx = Math.cos(turnAngle + t) * 1.5;
      dy = Math.sin(turnAngle + t) * 1.5;
      dz = 0.5;
    }
    
    x += dx; y += dy; z += dz;
    coords.push({x, y, z, aa, s: residueStates[i], i});
  });
  
  // Normalize and project
  const xs = coords.map(c=>c.x), ys = coords.map(c=>c.y), zs = coords.map(c=>c.z);
  const xmin=Math.min(...xs), xmax=Math.max(...xs);
  const ymin=Math.min(...ys), ymax=Math.max(...ys);
  const zmin=Math.min(...zs), zmax=Math.max(...zs);
  const range = Math.max(xmax-xmin, ymax-ymin, zmax-zmin) || 1;
  
  // Rotate
  const rotY = time * 0.008;
  const rotX = Math.sin(time * 0.003) * 0.3;
  
  const projected = coords.map(c => {
    const nx = (c.x - (xmin+xmax)/2) / range;
    const ny = (c.y - (ymin+ymax)/2) / range;
    const nz = (c.z - (zmin+zmax)/2) / range;
    
    // Rotation Y
    const rx = nx * Math.cos(rotY) - nz * Math.sin(rotY);
    const rz = nx * Math.sin(rotY) + nz * Math.cos(rotY);
    // Rotation X
    const ry2 = ny * Math.cos(rotX) - rz * Math.sin(rotX);
    const rz2 = ny * Math.sin(rotX) + rz * Math.cos(rotX);
    
    const perspective = 1 / (1 + rz2 * 0.3);
    return {
      sx: cx + rx * scale * perspective,
      sy: cy + ry2 * scale * perspective,
      depth: rz2,
      c,
      perspective,
    };
  });
  
  // Sort by depth for painter's algorithm
  projected.sort((a,b) => a.depth - b.depth);
  
  // Draw bonds
  const origOrder = coords.map((c,i) => ({idx:i, ...c}));
  
  // Draw backbone
  for(let i = 0; i < projected.length - 1; i++) {
    const p1 = projected[i];
    const p2 = projected.find(p => p.c.i === projected[i].c.i + 1);
    if(!p2) continue;
    
    const sp = STATE_PHI_PSI[p1.c.s];
    ctx.beginPath();
    ctx.moveTo(p1.sx, p1.sy);
    ctx.lineTo(p2.sx, p2.sy);
    
    const alpha = Math.max(0.2, 0.5 + p1.depth * 0.3);
    ctx.strokeStyle = sp.color + Math.round(alpha*255).toString(16).padStart(2,'0');
    ctx.lineWidth = p1.c.s === 'helix' ? 3 : p1.c.s === 'sheet' ? 4 : 1.5;
    ctx.stroke();
  }
  
  // Draw hydrogen bonds (dashed lines for helix)
  if(n < 60) {
    projected.forEach(p => {
      if(p.c.s === 'helix') {
        const partner = projected.find(q => q.c.i === p.c.i + 4);
        if(partner) {
          ctx.beginPath();
          ctx.setLineDash([3, 4]);
          ctx.moveTo(p.sx, p.sy);
          ctx.lineTo(partner.sx, partner.sy);
          ctx.strokeStyle = 'rgba(255,255,100,0.2)';
          ctx.lineWidth = 0.8;
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
    });
  }
  
  // Draw residue spheres
  projected.forEach(p => {
    const sp = STATE_PHI_PSI[p.c.s];
    const r = (p.c.i === selectedResidue ? 10 : 5) * p.perspective;
    const brightness = 0.4 + (p.depth + 1) * 0.3;
    
    const grad = ctx.createRadialGradient(p.sx - r*0.3, p.sy - r*0.3, r*0.1, p.sx, p.sy, r);
    const [R, G, B] = sp.colorRGB;
    grad.addColorStop(0, `rgba(${Math.min(255,R+80)},${Math.min(255,G+80)},${Math.min(255,B+80)},${brightness})`);
    grad.addColorStop(1, `rgba(${R},${G},${B},${brightness*0.5})`);
    
    ctx.beginPath();
    ctx.arc(p.sx, p.sy, r, 0, Math.PI*2);
    ctx.fillStyle = grad;
    ctx.fill();
    
    if(p.c.i === selectedResidue) {
      ctx.strokeStyle = sp.color;
      ctx.lineWidth = 2;
      ctx.stroke();
      // Label
      ctx.font = '11px -apple-system, sans-serif';
      ctx.fillStyle = sp.color;
      ctx.fillText(p.c.aa + (p.c.i+1), p.sx + r + 2, p.sy + 4);
    }
  });
  
  // Draw secondary structure labels
  let lastState = null, runStart = 0;
  for(let i = 0; i <= projected.length; i++) {
    const s = i < projected.length ? projected.find(p=>p.c.i===i)?.c.s : null;
    if(s !== lastState && lastState && runStart < i-2) {
      const midIdx = Math.floor((runStart + i) / 2);
      const midP = projected.find(p=>p.c.i===midIdx);
      if(midP) {
        ctx.font = 'bold 11px -apple-system, sans-serif';
        ctx.fillStyle = STATE_PHI_PSI[lastState].color;
        ctx.globalAlpha = 0.7;
        const labels = {helix:'α', sheet:'β', coil:'~', turn:'∩'};
        ctx.fillText(labels[lastState], midP.sx + 8, midP.sy - 8);
        ctx.globalAlpha = 1;
      }
    }
    if(s !== lastState) { lastState = s; runStart = i; }
  }
}

// ==================== ANIMATION ====================
function togglePlay() {
  isPlaying = !isPlaying;
  var btn = document.getElementById('btnPlay');
  btn.innerHTML = isPlaying ? '&#9646;&#9646;' : '&#9654;';
  btn.classList.toggle('playing', isPlaying);
}

function stepForward() {
  time += 10;
  monteCarloStep();
  render();
}

function resetAnim() {
  isPlaying = false;
  var btn = document.getElementById('btnPlay');
  btn.innerHTML = '&#9654;';
  btn.classList.remove('playing');
  time = 0;
  mcStep = 0;
  render();
}

// Single unified loop — controls both idle rotation and active playback
var mcTimer = 0;
function mainLoop() {
  if(isPlaying) {
    time += animSpeed * 0.5;
    mcTimer += animSpeed * 0.5;
    // trigger MC step periodically
    var mcInterval = Math.max(20, Math.floor(200 / animSpeed));
    if(mcTimer >= mcInterval) {
      mcTimer = 0;
      monteCarloStep();
    }
    render();
  } else {
    // idle: slow rotation only, no MC
    time += 0.1;
    render();
  }
  requestAnimationFrame(mainLoop);
}
setTimeout(function() { mainLoop(); }, 200);

// ==================== EXPORT PYMOL ====================
function exportPyMOL() {
  if(sequence.length === 0) return;
  
  const lines = [
    '# PyMOL Script: Protein Microstate Visualization',
    '# Generated by Protein Microstate Generator (Educational Tool)',
    '# Sequence: ' + sequence.join(''),
    '',
    '# Load or fetch protein (example: fetch 1ubq)',
    '# fetch 1ubq',
    '',
    '# Color by secondary structure state:',
    'def color_microstates():',
    '    stored.states = {}',
  ];
  
  // Group by state
  const stateGroups = {helix:[], sheet:[], coil:[], turn:[]};
  sequence.forEach((aa, i) => stateGroups[residueStates[i]].push(i+1));
  
  const pymolColors = {helix:'orange', sheet:'cyan', coil:'green', turn:'purple'};
  const stateNames = {helix:'α-Helix', sheet:'β-Sheet', coil:'Random Coil', turn:'β-Turn'};
  
  lines.push('');
  lines.push('# Color residues by microstate');
  Object.entries(stateGroups).forEach(([state, residues]) => {
    if(residues.length === 0) return;
    const selString = residues.map(r=>`resi ${r}`).join(' or ');
    lines.push(`# ${stateNames[state]} (${residues.length} residues)`);
    lines.push(`select ${state}_residues, (${selString})`);
    lines.push(`color ${pymolColors[state]}, ${state}_residues`);
    lines.push('');
  });
  
  // Animation
  lines.push('# Generate conformational ensemble');
  lines.push('def generate_ensemble(frames=20):');
  lines.push('    for i in range(frames):');
  lines.push('        cmd.turn("y", 18)  # rotate for movie');
  lines.push('        cmd.ray()');
  lines.push('');
  lines.push('# Show secondary structure');
  lines.push('show cartoon');
  lines.push('set cartoon_transparency, 0.2');
  lines.push('show spheres, (name ca)');
  lines.push('set sphere_scale, 0.3');
  lines.push('');
  lines.push('# Biophysical annotations');
  lines.push(`# Total residues: ${sequence.length}`);
  const p = calcBiophysics();
  lines.push(`# ΔG = ${p.deltaG} kcal/mol`);
  lines.push(`# H-bonds = ${p.hBonds}`);
  lines.push(`# Rg = ${p.Rg} nm`);
  lines.push('');
  lines.push('# Execute');
  lines.push('color_microstates()');
  lines.push('bg_color black');
  lines.push('set ray_opaque_background, 0');
  
  const script = lines.join('\n');
  const output = document.getElementById('pymolOutput');
  output.style.display = 'block';
  output.textContent = script;

  // Try File System Access API first (Chrome/Edge) — gives real Save As dialog
  if(window.showSaveFilePicker) {
    window.showSaveFilePicker({
      suggestedName: 'protein_microstates.pml',
      types: [{ description: 'PyMOL Script', accept: { 'text/plain': ['.pml'] } }]
    }).then(function(fileHandle) {
      return fileHandle.createWritable();
    }).then(function(writable) {
      writable.write(script);
      return writable.close();
    }).then(function() {
      logEvent('Экспортирован PyMOL скрипт (' + lines.length + ' строк)');
    }).catch(function(err) {
      if(err.name !== 'AbortError') {
        fallbackDownload(script, lines);
      }
    });
  } else {
    fallbackDownload(script, lines);
  }
}

function fallbackDownload(script, lines) {
  try {
    var blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'protein_microstates.pml';
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(function() { URL.revokeObjectURL(url); }, 1000);
    logEvent('Экспортирован PyMOL скрипт (' + lines.length + ' строк)');
  } catch(e) {
    // Last resort — show modal with content to copy
    var modal = document.getElementById('pymolModal');
    if(!modal) {
      modal = document.createElement('div');
      modal.id = 'pymolModal';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:9999;display:flex;align-items:center;justify-content:center;';
      modal.innerHTML = '<div style="background:#1c1c1e;border:1px solid #38383a;border-radius:12px;padding:24px;max-width:600px;width:90%;max-height:80vh;display:flex;flex-direction:column;gap:12px;">'
        + '<div style="display:flex;justify-content:space-between;align-items:center;">'
        + '<span style="color:#f5f5f7;font-size:14px;font-weight:600;">protein_microstates.pml</span>'
        + '<button onclick="document.getElementById(\'pymolModal\').remove()" style="background:none;border:none;color:#98989d;font-size:20px;cursor:pointer;">×</button>'
        + '</div>'
        + '<textarea id="pymolCopyArea" readonly style="flex:1;min-height:300px;background:#0d0d0f;border:1px solid #38383a;border-radius:8px;color:#30d158;font:11px JetBrains Mono,monospace;padding:12px;resize:vertical;"></textarea>'
        + '<button onclick="var t=document.getElementById(\'pymolCopyArea\');t.select();document.execCommand(\'copy\');" style="padding:8px;background:#0a84ff;border:none;border-radius:7px;color:#fff;font-size:13px;cursor:pointer;">Скопировать</button>'
        + '</div>';
      document.body.appendChild(modal);
    }
    document.getElementById('pymolCopyArea').value = script;
    document.getElementById('pymolModal').style.display = 'flex';
    logEvent('Скрипт готов — скопируйте из диалога');
  }
}

// ==================== LOG ====================
function logEvent(msg, isTransition) {
  const log = document.getElementById('logContainer');
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  const t = new Date().toLocaleTimeString('ru-RU');
  entry.innerHTML = '<span class="ts">[' + t + ']</span>' + (isTransition ? '<span class="ev">TRANSITION</span> ' : '') + msg;
  log.insertBefore(entry, log.firstChild);
  if(log.children.length > 50) log.removeChild(log.lastChild);
  transitionHistory.push({time: Date.now(), msg});
}

// ==================== KEYBOARD ====================
document.addEventListener('keydown', e => {
  if(e.key === ' ') { e.preventDefault(); togglePlay(); }
  if(e.key === 'ArrowRight') stepForward();
  if(e.key === 'r' || e.key === 'R') randomizeStates();
  if(e.key === 'm' || e.key === 'M') monteCarloStep();
  if(e.key === '+' || e.key === '=') zoomIn();
  if(e.key === '-') zoomOut();
  if(selectedResidue >= 0) {
    if(e.key === '1') applyState('helix');
    if(e.key === '2') applyState('sheet');
    if(e.key === '3') applyState('coil');
    if(e.key === '4') applyState('turn');
  }
});


</script>
</body>
</html>
